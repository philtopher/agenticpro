import { IStorage } from '../storage';
import { InsertTask, InsertCommunication, Task, Agent } from '@shared/schema';

export interface Project {
  id: string;
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  status: 'planning' | 'active' | 'completed' | 'cancelled';
  createdAt: Date;
  updatedAt: Date;
  metadata: any;
  tasks: Task[];
}

export class ProjectService {
  constructor(private storage: IStorage) {}

  async createProject(projectData: {
    title: string;
    description: string;
    priority?: 'low' | 'medium' | 'high';
    requirements?: string[];
    stakeholders?: string[];
    timeline?: string;
  }): Promise<Project> {
    const project: Project = {
      id: `proj_${Date.now()}`,
      title: projectData.title,
      description: projectData.description,
      priority: projectData.priority || 'medium',
      status: 'planning',
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: {
        requirements: projectData.requirements || [],
        stakeholders: projectData.stakeholders || [],
        timeline: projectData.timeline,
        autoCreated: true
      },
      tasks: []
    };

    console.log(`üìã Creating project: ${project.title}`);
    
    // Auto-generate initial tasks for the project
    const initialTasks = await this.generateInitialTasks(project);
    
    // Create tasks in storage
    for (const taskData of initialTasks) {
      const task = await this.storage.createTask(taskData);
      project.tasks.push(task);
    }

    // Auto-assign initial task to Product Manager
    if (project.tasks.length > 0) {
      await this.autoAssignInitialTask(project.tasks[0]);
    }

    return project;
  }

  private async generateInitialTasks(project: Project): Promise<InsertTask[]> {
    const tasks: InsertTask[] = [];
    
    // 1. Requirements Analysis Task
    tasks.push({
      title: `Requirements Analysis - ${project.title}`,
      description: `Analyze and document detailed requirements for ${project.title}. ${project.description}`,
      priority: project.priority,
      status: 'pending',
      assignedAgentId: null,
      metadata: {
        projectId: project.id,
        phase: 'requirements',
        autoGenerated: true,
        taskType: 'requirements_analysis'
      }
    });

    // 2. User Story Creation Task
    tasks.push({
      title: `User Stories - ${project.title}`,
      description: `Create comprehensive user stories for ${project.title} based on requirements analysis`,
      priority: project.priority,
      status: 'pending',
      assignedAgentId: null,
      metadata: {
        projectId: project.id,
        phase: 'analysis',
        autoGenerated: true,
        taskType: 'user_stories',
        dependsOn: 'requirements_analysis'
      }
    });

    // 3. Technical Architecture Task
    tasks.push({
      title: `Technical Architecture - ${project.title}`,
      description: `Design technical architecture and system design for ${project.title}`,
      priority: project.priority,
      status: 'pending',
      assignedAgentId: null,
      metadata: {
        projectId: project.id,
        phase: 'architecture',
        autoGenerated: true,
        taskType: 'architecture_design',
        dependsOn: 'user_stories'
      }
    });

    // 4. UI/UX Design Task
    tasks.push({
      title: `UI/UX Design - ${project.title}`,
      description: `Create UI/UX design mockups and wireframes for ${project.title}`,
      priority: project.priority,
      status: 'pending',
      assignedAgentId: null,
      metadata: {
        projectId: project.id,
        phase: 'design',
        autoGenerated: true,
        taskType: 'ui_ux_design',
        dependsOn: 'architecture_design'
      }
    });

    // 5. Development Planning Task
    tasks.push({
      title: `Development Planning - ${project.title}`,
      description: `Create development plan and implementation strategy for ${project.title}`,
      priority: project.priority,
      status: 'pending',
      assignedAgentId: null,
      metadata: {
        projectId: project.id,
        phase: 'planning',
        autoGenerated: true,
        taskType: 'development_planning',
        dependsOn: 'ui_ux_design'
      }
    });

    return tasks;
  }

  private async autoAssignInitialTask(task: Task): Promise<void> {
    // Always assign the first task to Product Manager (Sam)
    const agents = await this.storage.getAgents();
    const productManager = agents.find(a => a.type === 'product_manager');
    
    if (productManager) {
      await this.storage.assignTask(task.id, productManager.id);
      
      // Create assignment communication
      const assignmentComm: InsertCommunication = {
        fromAgentId: null,
        toAgentId: productManager.id,
        taskId: task.id,
        message: `New project task "${task.title}" has been automatically assigned to you. Please begin requirements analysis.`,
        messageType: 'task_assignment',
        metadata: {
          autoAssigned: true,
          projectInitiation: true,
          timestamp: new Date().toISOString()
        }
      };
      
      await this.storage.createCommunication(assignmentComm);
      console.log(`üìã Initial task assigned to ${productManager.name}: ${task.title}`);
    }
  }

  async autoCreateProjectFromRequest(request: {
    title?: string;
    description: string;
    context?: any;
    requester?: string;
  }): Promise<Project> {
    // Extract project details from natural language request
    const projectDetails = await this.extractProjectDetails(request);
    
    console.log(`üöÄ Auto-creating project from request: ${projectDetails.title}`);
    
    return await this.createProject(projectDetails);
  }

  private async extractProjectDetails(request: {
    title?: string;
    description: string;
    context?: any;
    requester?: string;
  }): Promise<{
    title: string;
    description: string;
    priority: 'low' | 'medium' | 'high';
    requirements: string[];
    stakeholders: string[];
    timeline?: string;
  }> {
    const description = request.description.toLowerCase();
    
    // Extract title if not provided
    let title = request.title;
    if (!title) {
      // Generate title from description
      if (description.includes('mobile app')) {
        title = 'Mobile Application Development';
      } else if (description.includes('web app') || description.includes('website')) {
        title = 'Web Application Development';
      } else if (description.includes('api')) {
        title = 'API Development';
      } else if (description.includes('database')) {
        title = 'Database System';
      } else {
        title = 'Software Development Project';
      }
    }

    // Determine priority from keywords
    let priority: 'low' | 'medium' | 'high' = 'medium';
    if (description.includes('urgent') || description.includes('critical') || description.includes('asap')) {
      priority = 'high';
    } else if (description.includes('when possible') || description.includes('future') || description.includes('nice to have')) {
      priority = 'low';
    }

    // Extract requirements from description
    const requirements: string[] = [];
    if (description.includes('user authentication')) requirements.push('User authentication system');
    if (description.includes('database')) requirements.push('Database integration');
    if (description.includes('api')) requirements.push('API development');
    if (description.includes('mobile')) requirements.push('Mobile compatibility');
    if (description.includes('responsive')) requirements.push('Responsive design');
    if (description.includes('payment')) requirements.push('Payment processing');
    if (description.includes('notification')) requirements.push('Notification system');
    if (description.includes('search')) requirements.push('Search functionality');
    if (description.includes('real-time')) requirements.push('Real-time features');
    if (description.includes('security')) requirements.push('Security implementation');

    // Default requirements if none found
    if (requirements.length === 0) {
      requirements.push('Core functionality implementation');
      requirements.push('User interface design');
      requirements.push('Testing and quality assurance');
    }

    // Extract stakeholders
    const stakeholders: string[] = [];
    if (request.requester) stakeholders.push(request.requester);
    if (description.includes('user') || description.includes('customer')) stakeholders.push('End users');
    if (description.includes('admin')) stakeholders.push('System administrators');
    if (description.includes('manager')) stakeholders.push('Project managers');

    return {
      title,
      description: request.description,
      priority,
      requirements,
      stakeholders,
      timeline: this.extractTimeline(description)
    };
  }

  private extractTimeline(description: string): string | undefined {
    if (description.includes('week')) return '1 week';
    if (description.includes('month')) return '1 month';
    if (description.includes('quarter')) return '3 months';
    if (description.includes('urgent')) return '3 days';
    if (description.includes('asap')) return '1 day';
    return undefined;
  }

  async getProjectStatus(projectId: string): Promise<any> {
    // This would typically fetch from a projects table
    // For now, we'll simulate it by finding related tasks
    const allTasks = await this.storage.getTasks();
    const projectTasks = allTasks.filter(t => t.metadata?.projectId === projectId);
    
    return {
      projectId,
      taskCount: projectTasks.length,
      completedTasks: projectTasks.filter(t => t.status === 'completed').length,
      activeTasks: projectTasks.filter(t => t.status === 'active').length,
      pendingTasks: projectTasks.filter(t => t.status === 'pending').length,
      progress: projectTasks.length > 0 ? 
        (projectTasks.filter(t => t.status === 'completed').length / projectTasks.length) * 100 : 0
    };
  }

  async createTaskFromInstruction(instruction: {
    description: string;
    priority?: 'low' | 'medium' | 'high';
    assignTo?: string;
    projectId?: string;
    context?: any;
  }): Promise<Task> {
    // Extract task details from instruction
    const taskDetails = await this.extractTaskDetails(instruction);
    
    // Create task
    const task = await this.storage.createTask(taskDetails);
    
    // Auto-assign if specified
    if (instruction.assignTo) {
      await this.autoAssignTaskByType(task, instruction.assignTo);
    }
    
    console.log(`üìù Created task from instruction: ${task.title}`);
    return task;
  }

  private async extractTaskDetails(instruction: {
    description: string;
    priority?: 'low' | 'medium' | 'high';
    assignTo?: string;
    projectId?: string;
    context?: any;
  }): Promise<InsertTask> {
    const description = instruction.description.toLowerCase();
    
    // Generate title from description
    let title = instruction.description;
    if (description.length > 50) {
      title = description.substring(0, 47) + '...';
    }

    // Determine task type
    let taskType = 'general';
    if (description.includes('user stor')) taskType = 'user_stories';
    if (description.includes('test')) taskType = 'testing';
    if (description.includes('code') || description.includes('develop')) taskType = 'development';
    if (description.includes('design')) taskType = 'design';
    if (description.includes('review')) taskType = 'review';
    if (description.includes('deploy')) taskType = 'deployment';

    return {
      title,
      description: instruction.description,
      priority: instruction.priority || 'medium',
      status: 'pending',
      assignedAgentId: null,
      metadata: {
        projectId: instruction.projectId,
        taskType,
        autoGenerated: true,
        context: instruction.context
      }
    };
  }

  private async autoAssignTaskByType(task: Task, agentType: string): Promise<void> {
    const agents = await this.storage.getAgents();
    
    // Map common names to agent types
    const typeMapping: Record<string, string> = {
      'sam': 'product_manager',
      'bailey': 'business_analyst',
      'dex': 'developer',
      'tess': 'qa_engineer',
      'ollie': 'product_owner',
      'sienna': 'solution_designer',
      'aria': 'solutions_architect',
      'nova': 'devops_engineer',
      'emi': 'engineering_lead',
      'zara': 'admin_governor',
      'product manager': 'product_manager',
      'business analyst': 'business_analyst',
      'developer': 'developer',
      'qa engineer': 'qa_engineer',
      'product owner': 'product_owner'
    };

    const targetType = typeMapping[agentType.toLowerCase()] || agentType.toLowerCase();
    const agent = agents.find(a => a.type === targetType && a.status === 'active');
    
    if (agent) {
      await this.storage.assignTask(task.id, agent.id);
      
      // Create assignment communication
      const assignmentComm: InsertCommunication = {
        fromAgentId: null,
        toAgentId: agent.id,
        taskId: task.id,
        message: `Task "${task.title}" has been automatically assigned to you.`,
        messageType: 'task_assignment',
        metadata: {
          autoAssigned: true,
          assignmentType: 'by_instruction',
          timestamp: new Date().toISOString()
        }
      };
      
      await this.storage.createCommunication(assignmentComm);
      console.log(`üìã Task auto-assigned to ${agent.name}: ${task.title}`);
    }
  }

  async handleProjectCreationRequest(message: string, context?: any): Promise<Project | null> {
    // Check if message is requesting project creation
    const lowerMessage = message.toLowerCase();
    
    const projectKeywords = ['create project', 'new project', 'start project', 'project for', 'build a', 'develop a', 'make a'];
    const isProjectRequest = projectKeywords.some(keyword => lowerMessage.includes(keyword));
    
    if (isProjectRequest) {
      return await this.autoCreateProjectFromRequest({
        description: message,
        context,
        requester: 'user'
      });
    }
    
    return null;
  }

  async handleTaskCreationRequest(message: string, context?: any): Promise<Task | null> {
    // Check if message is requesting task creation
    const lowerMessage = message.toLowerCase();
    
    const taskKeywords = ['create task', 'new task', 'add task', 'task for', 'need to', 'can you'];
    const isTaskRequest = taskKeywords.some(keyword => lowerMessage.includes(keyword));
    
    if (isTaskRequest) {
      return await this.createTaskFromInstruction({
        description: message,
        context
      });
    }
    
    return null;
  }
}